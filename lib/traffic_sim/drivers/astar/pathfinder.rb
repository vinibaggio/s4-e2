require_relative 'node'
require_relative 'nodemap'
require_relative 'maptools'
require_relative 'movement'

module TrafficSim
  module Drivers
    class AStar
      class Pathfinder
        def initialize(map)
          @node_map = NodeMap.new(map)
        end

        # This is an implementation of the A* path finder algorithm.
        # This implementation was based on the following article:
        # http://www.policyalmanac.org/games/aStarTutorial.htm
        def find_path(start_position, final_position, start_direction)
          available_positions = [start_position]

          while !available_positions.empty? && !@node_map.visited?(final_position)

            current_position = lowest_cost_position(available_positions)
            available_positions.delete(current_position)

            @node_map.mark_as_visited(current_position)

            surroundings = possible_surroundings(current_position, final_position)
            surroundings.each do |position|
              movement = Movement.new({
                :vehicle_direction => start_direction,
                :current_position  => current_position,
                :next_position     => position,
                :final_position    => final_position
              })

              node = @node_map[*position]

              if available_positions.include?(position)
                node.update(movement) if node.walking_cost > movement.walking_cost
              else
                available_positions << position
                node.update(movement)
              end
            end
          end

          make_path(start_position, final_position)
        end

        private
        def lowest_cost_position(positions)
          positions.sort_by do |position|
            @node_map[*position].total_cost
          end.first
        end

        def possible_surroundings(current_position, final_position)
          surroundings = @node_map.map_surroundings(current_position)
          surroundings = walkable(surroundings, final_position)
          surroundings.reject { |pos| @node_map.visited?(pos) }
        end

        def walkable(positions, final_position)
          positions.select do |position|
            # The final position is always walkable.
            @node_map[*position].walkable? || position == final_position
          end
        end

        # The path is generated by going to the last position,
        # follow its parent until we're back in the original position.
        # So we get all these positions and reverse them to make it more
        # obvious (from origin to destination)
        def make_path(start_position, final_position)
          path = []

          position = final_position
          while position != start_position
            path << position
            position = @node_map[*position].parent_position
          end

          path.reverse
        end

      end
    end
  end
end
