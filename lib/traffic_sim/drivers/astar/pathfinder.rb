require_relative 'node'
require_relative 'nodemap'
require_relative 'maptools'

module TrafficSim
  module Drivers
    class AStar
      class Pathfinder
        MOVEMENT_MASK = {
          :north => [-1, 0],
          :south => [1, 0],
          :east  => [0, 1],
          :west  => [0, -1]
        }.freeze

        DIRECTION = MOVEMENT_MASK.invert.freeze

        MOVEMENT_COST = 10

        def initialize(map)
          @node_map = NodeMap.new(map)
        end

        # This is an implementation of the A* path finder algorithm.
        # This implementation was based on the following article:
        # http://www.policyalmanac.org/games/aStarTutorial.htm
        def find_path(start_position, final_position, start_direction)
          available_positions = [start_position]

          while !available_positions.empty? && !@node_map.visited?(final_position)

            current_position = lowest_cost_position(available_positions)
            available_positions.delete(current_position)

            @node_map.mark_as_visited(current_position)

            surroundings = possible_surroundings(current_position, final_position)
            surroundings.each do |position|
              params = {
                :vehicle_direction => start_direction,
                :current_position  => current_position,
                :next_position     => position,
                :final_position    => final_position
              }
              walking_cost = walking_cost(params)
              destination_cost = destination_cost(params)
              total_cost = walking_cost + destination_cost

              node = @node_map[*position]

              update_node = false

              if available_positions.include?(position)
                update_node = node.walking_cost > walking_cost
              else
                update_node = true
                available_positions << position
              end

              if update_node
                node.parent_position  = current_position
                node.walking_cost     = walking_cost
                node.destination_cost = destination_cost
                node.total_cost       = total_cost
              end
            end
          end

          make_path(start_position, final_position)
        end

        private
        def lowest_cost_position(positions)
          positions.sort_by do |position|
            @node_map[*position].total_cost
          end.first
        end

        def possible_surroundings(current_position, final_position)
          surroundings = @node_map.map_surroundings(current_position)
          surroundings = walkable(surroundings, final_position)
          surroundings.reject { |pos| @node_map.visited?(pos) }
        end

        def walkable(positions, final_position)
          positions.select do |position|
            # The final position is always walkable.
            @node_map[*position].walkable? || position == final_position
          end
        end

        # The path is generated by going to the last position,
        # follow its parent until we're back in the original position.
        # So we get all these positions and reverse them to make it more
        # obvious (from origin to destination)
        def make_path(start_position, final_position)
          path = []

          position = final_position
          while position != start_position
            path << position
            position = @node_map[*position].parent_position
          end

          path.reverse
        end

        # The walking cost is based on the idea that moving the car is not
        # so simple.
        #
        # Imagine that if the car is moving north, but now it must turn left.
        # It should reduce its speed, move its direction, increase its speed
        # to finally start walking. So each change of direction accounts for 3
        # movements, which has high cost.
        #
        # To calculate the number of movements, we use simple Hamming distance.
        # It is basically the number of space slots it has to move. The
        # Hamming distance is given by calculating the difference for each
        # index of the position
        #
        # Example:
        #
        # Vehicle a has to move from [1,1] to [2,2]. So it must move south
        # and then left. The hamming distance is calculated as the following:
        # |1 - 2| + |1 - 2| = 1 + 1 = 2 slots.
        #
        # With that in mind, we first check if the next position is achievable
        # by only going forward. That is achieved by applying MOVEMENT_MASK
        # and calculate the hamming distances.
        #
        # We pick whichever path that has the least hamming distances, multiply
        # it by the MOVEMENT_COST and then by 3, which is the number of
        # commands the system needs to achieve the movement.
        def walking_cost(params)
          vehicle_direction = params[:vehicle_direction]
          current_position  = params[:current_position]
          next_position     = params[:next_position]
          points            = 0

          movement_mask = MOVEMENT_MASK[vehicle_direction]

          forward_position         = MapTools.add_vectors(current_position, movement_mask)
          hamming_distance         = hamming_distance(current_position,
                                                      next_position)
          forward_hamming_distance = hamming_distance(forward_position,
                                                      next_position)

          if hamming_distance < forward_hamming_distance
            points += hamming_distance * MOVEMENT_COST * 3
          else
            points += MOVEMENT_COST
            points += forward_hamming_distance * MOVEMENT_COST * 3
          end

          points
        end

        # Calculate a rough estimate of cost of movement to reach
        # the docking using Manhattan method. Need improvements.
        #
        # Estimate two direction changes, and remember that each direction
        # change costs 3 * MOVEMENT_COST
        def destination_cost(params)
          current_position = params[:current_position]
          final_position = params[:final_position]

          hamming_distance(current_position, final_position) * MOVEMENT_COST +
            (2 * 3 * MOVEMENT_COST)
        end

        def hamming_distance(point_a, point_b)
          (0..1).inject(0) do |sum, idx|
            sum += (point_a[idx] - point_b[idx]).abs
          end
        end
      end
    end
  end
end
